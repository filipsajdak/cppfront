template<int I>
struct X { operator int() const { return I; } };

template <std::size_t... Is>
auto make_variant(std::index_sequence<Is...>){
    return std::variant<X<Is>...>{};
}

template <typename F, template<typename...> class C, typename... Ts>
constexpr auto for_each_type(C<Ts...>, F&& fun)
{
    [&]<std::size_t... Is>(std::index_sequence<Is...>){
        if constexpr ( requires { (fun(cpp2::type_it<Is, Ts>{}), ...); } ) {
            (fun(cpp2::type_it<Is, Ts>{}), ...);
        }
    }(std::index_sequence_for<Ts...>());
}

main: () -> int = {

    v := make_variant(std::make_index_sequence<30>());

    for_each_type(v, :<T>(x : T) = {
        v&$* = X<T::index>(); std::cout << "v as X<" << std::setw(2) << T::index << "> = " << std::setw(1) << v&$* as X<T::index> as int << std::endl;
    });

    for_each_type(v, :<T>(x : T) = {
        v&$* = X<T::index>(); std::cout << "as_const(v) as X<" << std::setw(2) << T::index << "> = " << std::setw(1) << std::as_const(v&$*) as X<T::index> as int << std::endl;
    });

    for_each_type(v, :<T>(x : T) = {
        v&$* = X<T::index>(); std::cout << "move(v) as X<" << std::setw(2) << T::index << "> = " << std::setw(1) << (move v&$*) as X<T::index> as int << std::endl;
    });

}

#include <iomanip>